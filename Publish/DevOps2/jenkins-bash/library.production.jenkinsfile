def remote = [:]
remote.name = "dind-ssh"
remote.host = "dind"
remote.port = 22
remote.user = "  "
remote.password = "  "
remote.allowAnyHosts = true

pipeline {
    agent any

    environment {
        APPNAME = "Sers"
        stageName = "production"
        versionSuffix = "  "

        basePath = "/root/docker-cache/jenkins/jenkins_home/workspace/${APPNAME}/${stageName}/${env.build_number}"
        // set to "  "  if want to skip copy
        releasePath = "/root/docker-cache/jenkins/jenkins_home/jenkinsReleaseFile/${stageName}/${APPNAME}"


        SVN_PATH = "svn://svn.ki.lith.cloud/Sers"
        //svn_USR = "  "
        //svn_PSW = "  "
        svn = credentials("svn_account")

        NUGET_PATH = "/root/docker-cache/jenkins/jenkins_home/workspace/.nuget"

        NUGET_SERVER = "http://nuget.lith.cloud:8"
        //NUGET_KEY = " "
        NUGET_KEY = credentials("nuget_key")

        DOCKER_ImagePrefix = "docker.lith.cloud:8/"
        DOCKER_Buildx = true
        DOCKER_USERNAME = " "
        DOCKER_PASSWORD = " "

        build_crossPlatform = "yes"
        svn_createReleaseBranch = "yes"
        svn_changeToNextTempVersion = "yes"

        dind_ssh_account = credentials("dind_ssh_account")
    }

    stages {
        stage('#1 deploy ?') {
            steps {
                timeout(time:600,unit:'SECONDS') {
                    script {
                        remote.user = "${dind_ssh_account_USR}"
                        remote.password = "${dind_ssh_account_PSW}"

                        env.codePath = "$basePath/build"

                        env.inputChoice = "no"
                        env.inputChoice = input message: "deploy ?", 
                            ok: 'Proceed?', 
                            parameters: [choice(choices:["yes","no"], description: 'if not please select no', name: 'choice')]
                    }
                }
            }
        }

        stage('#2 pull code') {
            when { expression { env.inputChoice == "yes" } }
            steps {
                script {
                    echo "#1.1 pull code from svn to Path: $codePath"
                    sshCommand remote: remote, command:  "sh -c 'set -e; mkdir -p $codePath;chmod 777 $codePath;    docker run -i --rm -v $codePath:/root/svn serset/svn-client svn checkout \"$SVN_PATH/branches/develop\" /root/svn --username \"$svn_USR\" --password \"$svn_PSW\" --no-auth-cache > /dev/null;  '"

                    echo "#1.2 change-app-version"
                    sshCommand remote: remote, command:  "sh -c 'set -e; export versionSuffix=$versionSuffix;    cd $codePath/Publish/DevOps2/build-bash; sh 20.change-app-version.bash;  '"
                }
            }
        }

        stage('#3.1 build - single platflorm') {
            when { expression { env.inputChoice == "yes" } }
            steps {
                script {
                    sshCommand remote: remote, command:  "sh -c 'set -e; export APPNAME=$APPNAME; export NUGET_PATH=$NUGET_PATH;    cd $codePath/Publish/DevOps2/build-bash; sh startup.bash;  '"
                }
            }
        }

        stage('#3.2 build - cross platform') {
            when { expression { env.inputChoice == "yes" && env.build_crossPlatform == "yes" } }
            steps {
                script {
                    sshCommand remote: remote, command:  "sh -c 'set -e; export APPNAME=$APPNAME; export NUGET_PATH=$NUGET_PATH;    cd $codePath/Publish/DevOps2/build-bash; sh 40.Station-publish-multiple.bash;  '"
                }
            }
        }

        stage('#4 publish') {
            when { expression { env.inputChoice == "yes" } }
            steps {
                script {
                    sshCommand remote: remote, command:  "sh -c 'set -e; export APPNAME=$APPNAME;export NUGET_PATH=$NUGET_PATH;    export NUGET_SERVER=$NUGET_SERVER;export NUGET_KEY=$NUGET_KEY;  export DOCKER_Buildx=${env.DOCKER_Buildx};export DOCKER_ImagePrefix=${env.DOCKER_ImagePrefix};export DOCKER_USERNAME=${env.DOCKER_USERNAME};export DOCKER_PASSWORD=${env.DOCKER_PASSWORD};export DOCKER_BuildxExtArgs=\"--output=type=registry,registry.insecure=true\";    cd $codePath/Publish/DevOps2/release-bash; sh startup.bash;  '"
                }
            }
        }

        stage('#5 copy release files') {
            when { expression { env.inputChoice == "yes" && env.releasePath != "  " } }
            steps {
                script {
                    sshCommand remote: remote, command:  "sh -c 'set -e; export versionSuffix=$versionSuffix;    cd $codePath/Publish/DevOps2/build-bash; source 19.get-app-version.bash;    echo \"copy release files : $codePath/Publish/release/release-zip/. $releasePath/\$appVersion;\"; mkdir -p $releasePath;  \\cp -rf $codePath/Publish/release/release-zip/. $releasePath/\$appVersion;    '"
                }
            }
        }

        stage('#6.1 code - create release branch') {
            when { expression { env.inputChoice == "yes" && env.svn_createReleaseBranch == "yes" } }
            steps {
                script {
                    sshCommand remote: remote, command:  "sh -c 'set -e; export codePath=\"$basePath/code-createReleaseBranch\";export SVN_PATH=$SVN_PATH;export SVN_USERNAME=\"$svn_USR\";export SVN_PASSWORD=\"$svn_PSW\";  export versionSuffix=$versionSuffix;    cd $codePath/Publish/DevOps2/jenkins-bash; sh 06.svn-createReleaseBranch.bash;  '"
                }
            }
        }

        stage('#6.2 code - next temp version') {
            when { expression { env.inputChoice == "yes" && env.svn_changeToNextTempVersion == "yes" } }
            steps {
                script {
                    sshCommand remote: remote, command:  "sh -c 'set -e; export codePath=\"$basePath/code-nextTempVersion\";export SVN_PATH=$SVN_PATH;export SVN_USERNAME=\"$svn_USR\";export SVN_PASSWORD=\"$svn_PSW\";   cd $codePath/Publish/DevOps2/jenkins-bash; sh 07.svn-changeToNextTempVersion.bash;  '"
                }
            }
        }

    }

    post {
        always {
            timeout(time:3600,unit:'SECONDS') {
                script {
                    env.inputChoice = "yes"
                    env.inputChoice = input message: "Clean temp files, \n will wait for 3600 seconds. \n click abort to skip clean.", 
                            ok: 'Proceed', 
                            parameters: [choice(choices:["yes","no"], name: 'choice')]
               }
            }
            script {
                if ( inputChoice == "yes" ) {
                    echo "clean temp files"
                    sshCommand remote: remote, command:  "rm -rf $basePath"
                }
            }
        }
        success {
            echo "build success !"
        }
        failure {
            echo "build failure !"
        }
        aborted {
            echo "build aborted !"
        }
    }
}